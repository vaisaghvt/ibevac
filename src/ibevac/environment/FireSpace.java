package ibevac.environment;

import ibevac.cue.FireAlarmCue;
import ibevac.datatypes.SmallRoom;
import ibevac.cue.FireCue;
import ibevac.datatypes.CArea;
import ibevac.datatypes.CEvacuationScenario;
import ibevac.datatypes.CFire;
import ibevac.datatypes.CFloor;
import ibevac.datatypes.CStaircase;
import ibevac.engine.IbevacModel;
import ibevac.utilities.IbevacRNG;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import sim.engine.SimState;
import sim.engine.Steppable;
import sim.engine.Stoppable;
import sim.field.grid.ObjectGrid2D;

/**
 * This class is responsible for handling fire.
 * 
 * 
 * 
 *  @author     <A HREF="mailto:vaisagh1@e.ntu.edu.sg">Vaisagh</A>
 *  @version    $Revision: 1.0.0.0 $ $Date: 16/Apr/2012 $
 */
public final class FireSpace implements Steppable {

    /**
     * Prob. that a cell burns given that it's neighbours are burning
     */
    private static final float PROBABILITY_OF_BURNING = 0.001f;
    /**
     * Probability that a cell at the fire front becomes a smoke generator.
     */
    private static final float PROBABILITY_OF_SMOKE_GENERATION = 0.01f;
    /**
     * For checkpointing
     */
    private static final long serialVersionUID = 1L;
    /**
     * As the name suggests, this boolean is true when the fire alarm is on and
     * false otherwise
     */
    private boolean fireAlarmRunning = false;
    /**
     * A reference to the smoke space so that smoke is generated by the fire.
     */
    private final SmokeSpace smokeSpace;
    /**
     * A reference to the fire production engine stoppable
     */
    public Stoppable stoppable = null;
    /**
     * The fields of ObjectGrids which are used for protraying the fire.
     */
    private ArrayList<ObjectGrid2D> fireSpaces;
    // private double pkill = 0.0001;
    /**
     * The 3D array of cells for fire. First index is the floor, second the width 
     * and third the height
     */
    private Cell[][][] cells = null;
    private int width = 0;
    private int height = 0;
    private int resolution = 1;
    /**
     * The fire front is stored seperately so that the spreading of the fire can
     * be modelled effectively.
     */
    private HashSet<Cell> firefront = new HashSet<Cell>();
    /**
     *  To keep a track of small rooms that on fire to increase the effectiveness 
     * of fire cue usage.
     */
    private HashSet<SmallRoom> smallRoomsOnFire = new HashSet<SmallRoom>();
    private IbevacSpace space;

    /**
     * Sets up the environment for fire propagation and sets things in motion by
     * starting the initial fire from paramaters passed to it. Gives instructions 
     * to start the fire alarm as well.
     * @param scenario
     * @param resolution 
     * @param smokeSpace
     * @param space 
     */
    public FireSpace(CEvacuationScenario scenario, int resolution,
            SmokeSpace smokeSpace, IbevacSpace space) {
        this.resolution = resolution;
        this.space = space;
        this.smokeSpace = smokeSpace;

        for (CFloor floor : scenario.getFloors()) {
            if (floor.getWidth() > width) {
                width = floor.getWidth();
            }
            if (floor.getHeight() > height) {
                height = floor.getHeight();
            }
        }

        width /= resolution;
        height /= resolution;
//        System.out.println(width);

        cells = new Cell[scenario.getFloors().size() * 2][width][height];
        fireSpaces = new ArrayList<ObjectGrid2D>(scenario.getFloors().size());
        for (int i = 0; i < scenario.getFloors().size(); ++i) {
            fireSpaces.add(new ObjectGrid2D(width, height));
        }

        for (int i = 0; i < cells.length; ++i) {
            for (int j = 0; j < cells[i].length; ++j) {
                for (int k = 0; k < cells[i][j].length; ++k) {
                    cells[i][j][k] = new Cell(i, j, k);
                }
            }
        }
        for (int i = 0; i < cells.length; ++i) {
            for (int j = 0; j < cells[i].length; ++j) {
                for (int k = 0; k < cells[i][j].length; ++k) {
                    cells[i][j][k].initializeNeighbours();
                }
            }
        }

        // initialise the cells
        for (int i = 0; i < scenario.getFloors().size(); i++) {
            int l = 2 * i;
            if (!fireAlarmRunning) {
                startFireAlarm();
            }
            CFloor floor = scenario.getFloors().get(i);

            HashSet<CArea> areas = new HashSet<CArea>();
            areas.addAll(floor.getRooms());
            areas.addAll(floor.getStaircases());
            areas.addAll(floor.getLinks());

            for (CArea area : areas) {
                int mnx = Math.min(area.getCorner0().getX(), area.getCorner1().getX())
                        / resolution - 1;
                int mny = Math.min(area.getCorner0().getY(), area.getCorner1().getY())
                        / resolution - 1;
                int mxx = Math.max(area.getCorner0().getX(), area.getCorner1().getX())
                        / resolution - 1;
                int mxy = Math.max(area.getCorner0().getY(), area.getCorner1().getY())
                        / resolution - 1;

                for (int j = mnx; j < mxx; ++j) {
                    for (int k = mny; k < mxy; ++k) {
                        cells[l][j][k].setState(CellState.UNBURNED);
                    }
                }

                if (area instanceof CStaircase) {
                    for (int j = mnx; j < mxx; ++j) {
                        for (int k = mny; k < mxy; ++k) {
                            if (l > 0) {
                                cells[l - 1][j][k].setState(CellState.UNBURNED);
                            }
                            if (l < cells.length - 1) {
                                cells[l + 1][j][k].setState(CellState.UNBURNED);
                            }
                        }
                    }
                }
            }
        }

        // start initial fires..
        HashSet<Cell> burning = new HashSet<Cell>();
        for (int i = 0; i < scenario.getFloors().size(); ++i) {
            int l = 2 * i;
            CFloor floor = scenario.getFloors().get(i);

            for (CFire fire : floor.getFires()) {
                int mnx = Math.min(fire.getCorner0().getX(), fire.getCorner1().getX())
                        / resolution;
                int mny = Math.min(fire.getCorner0().getY(), fire.getCorner1().getY())
                        / resolution;
                int mxx = Math.max(fire.getCorner0().getX(), fire.getCorner1().getX())
                        / resolution;
                int mxy = Math.max(fire.getCorner0().getY(), fire.getCorner1().getY())
                        / resolution;

                for (int j = mnx; j < mxx; ++j) {
                    for (int k = mny; k < mxy; ++k) {
                        cells[l][j][k].ignite();
                        burning.add(cells[l][j][k]);
                    }
                }
            }
        }

        // determine the fire front
        for (Cell cell : burning) {
            for (Cell n : cell.neighbors()) {
                if (n.state == CellState.UNBURNED) {
                    this.firefront.add(cell);
                    break;
                }
            }
        }

    }

    /**
     * Schedule the fire for the appropriate time
     * @param model
     * @param ordering
     * @param timestep 
     */
    public void schedule(IbevacModel model, int ordering, double timestep) {
        this.stoppable = model.schedule.scheduleRepeating(this, ordering,
                timestep);
    }

    /**
     * The step() in which first the burnable cellsa re set to burning with a 
     * given probablitiy. Then smoek generators are created. The burning cells 
     * are then actually ignited and the location of the fire front is changed.
     * @param state 
     */
    @Override
    public void step(SimState state) {
        // select at-risk-cells that will catch fire

//        if (state.schedule.getSteps() == 1000) {
//            this.stopFireAlarm();
//        }
        HashSet<Cell> burning = new HashSet<Cell>();
        for (Cell cell : this.firefront) {
            for (Cell n : cell.neighbors()) {
                if (n.state == CellState.UNBURNED) {
                    double p = n.bcount * PROBABILITY_OF_BURNING;
                    if (IbevacRNG.instance().nextDouble() < p) {
                        burning.add(n);
                    }
                    p = n.bcount * PROBABILITY_OF_SMOKE_GENERATION;

                    if (IbevacRNG.instance().nextDouble() < p) {
                        smokeSpace.addGenerator(n.i*resolution, n.j*resolution, n.k*resolution);
//                    System.out.println("generating");
                    }//else{
//                    System.out.println("not yet");
//                }
                }
            }
        }

        // now ignite them
        for (Cell cell : burning) {
            cell.ignite();
        }

        // determine the fire front
        burning.addAll(this.firefront);
        HashSet<Cell> localFireFront = new HashSet<Cell>();
        for (Cell cell : burning) {
            for (Cell n : cell.neighbors()) {
                if (n.state == CellState.UNBURNED) {
                    localFireFront.add(cell);
                    break;
                }
            }
        }

        // replace
        this.firefront = localFireFront;
    }

    /**
     * Determines the lethality of the region by determining whether the cell in 
     * that location is burning ordestroyed.
     * @param floorIdx
     * @param x
     * @param y
     * @return 
     */
    public boolean isAreaLethal(int floorIdx, int x, int y) {
        int i = 2 * floorIdx;
        int j = x / resolution;
        int k = y / resolution;

        if (j < 0 || j >= cells[i].length || k < 0 || k >= cells[i][j].length) {
            return true;
        }

        Cell cell = cells[i][j][k];
        return cell.state == CellState.BURNING
                || cell.state == CellState.DESTROYED;
    }

    /**
     * @return the fireSpace of that floor
     */
    public ObjectGrid2D getFireSpace(int floor) {

        return fireSpaces.get(floor);
    }

    /**
     * Starts the fire alarm and adds the fire alarm cue to allthe small rooms
     */
    public void startFireAlarm() {

        for (CArea area : space.getAllRooms()) {

            space.putCueInArea(
                    new FireAlarmCue(
                    (area.getCorner0().getX() + area.getCorner1().getX()) / 2,
                    (area.getCorner0().getY() + area.getCorner1().getY()) / 2),
                    area.getId());
        }
        fireAlarmRunning = true;

    }

    /**
     * Stops the fire alarm and remoces the cues from all the small rooms
     */
    public void stopFireAlarm() {

        for (CArea area : space.getAllRooms()) {
            space.removeCueFromRoom(new FireAlarmCue(
                    (area.getCorner0().getX() + area.getCorner1().getX()) / 2,
                    (area.getCorner0().getY() + area.getCorner1().getY()) / 2),
                    area.getId());
        }
        fireAlarmRunning = false;
    }

   
    /**
     * The cells which are the actual building blocks of the fire simulation 
     * cellular automata.
     */
    private class Cell {

        private int i = -1;
        private int j = -1;
        private int k = -1;
        
        /**
         * Number of neighbours that are burning
         */
        private int bcount = 0;
        private CellState state = CellState.EMPTY;
        private Set<Cell> neighbors;

        public Cell(int i, int j, int k) {
            this.i = i;
            this.j = j;
            this.k = k;
            if (i % 2 == 0) {
                fireSpaces.get(i / 2).set(j, k, state);
            }
        }

        public void initializeNeighbours(){
            neighbors = new HashSet<Cell>();

            if (j > 0) {
                neighbors.add(cells[i][j - 1][k]); // west
            }
            if (j < width - 1) {
                neighbors.add(cells[i][j + 1][k]); // east
            }
            if (k > 0) {
                neighbors.add(cells[i][j][k - 1]); // north
            }
            if (k < height - 1) {
                neighbors.add(cells[i][j][k + 1]); // south
            }
            if (j > 0 && k > 0) {
                neighbors.add(cells[i][j - 1][k - 1]); // north-west
            }
            if (j > 0 && k < height - 1) {
                neighbors.add(cells[i][j - 1][k + 1]); // south-west
            }
            if (j < width - 1 && k > 0) {
                neighbors.add(cells[i][j + 1][k - 1]); // north-east
            }
            if (j < width - 1 && k < height - 1) {
                neighbors.add(cells[i][j + 1][k + 1]); // south-east
            }
            if (i > 0) {
                if (j > 0) {
                    neighbors.add(cells[i - 1][j - 1][k]); // west
                }
                if (j < width - 1) {
                    neighbors.add(cells[i - 1][j + 1][k]); // east
                }
                if (k > 0) {
                    neighbors.add(cells[i - 1][j][k - 1]); // north
                }
                if (k < height - 1) {
                    neighbors.add(cells[i - 1][j][k + 1]); // south
                }
                neighbors.add(cells[i - 1][j][k]); // center

                if (j > 0 && k > 0) {
                    neighbors.add(cells[i - 1][j - 1][k - 1]); // north-west
                }
                if (j > 0 && k < height - 1) {
                    neighbors.add(cells[i - 1][j - 1][k + 1]); // south-west
                }
                if (j < width - 1 && k > 0) {
                    neighbors.add(cells[i - 1][j + 1][k - 1]); // north-east
                }
                if (j < width - 1 && k < height - 1) {
                    neighbors.add(cells[i - 1][j + 1][k + 1]); // south-east
                }
            }
            if (i < cells.length - 1) {
                if (j > 0) {
                    neighbors.add(cells[i + 1][j - 1][k]); // west
                }
                if (j < width - 1) {
                    neighbors.add(cells[i + 1][j + 1][k]); // east
                }
                if (k > 0) {
                    neighbors.add(cells[i + 1][j][k - 1]); // north
                }
                if (k < height - 1) {
                    neighbors.add(cells[i + 1][j][k + 1]); // south
                }
                neighbors.add(cells[i + 1][j][k]); // center

                if (j > 0 && k > 0) {
                    neighbors.add(cells[i + 1][j - 1][k - 1]); // north-west
                }
                if (j > 0 && k < height - 1) {
                    neighbors.add(cells[i + 1][j - 1][k + 1]); // south-west
                }
                if (j < width - 1 && k > 0) {
                    neighbors.add(cells[i + 1][j + 1][k - 1]); // north-east
                }
                if (j < width - 1 && k < height - 1) {
                    neighbors.add(cells[i + 1][j + 1][k + 1]); // south-east
                }
            }

        }
        
        /** 
         * Change the cells state to burning if it is burnable and create 
         * appropriate cues
         */
        public void ignite() {
            if (state == CellState.UNBURNED) {

                state = CellState.BURNING;

                if (i % 2 == 0) {
                    SmallRoom smallRoom = space.getSmallRoomOfPoint(j * resolution, k * resolution, i / 2);
                    if (smallRoom != null) {
                        if (!smallRoomsOnFire.contains(smallRoom)) {
                            space.putCueInSmallRoom(new FireCue(j * resolution, k * resolution), smallRoom);
                            smallRoomsOnFire.add(smallRoom);
                        }
                    }
                    fireSpaces.get(i / 2).set(j, k, state);
                }

                for (Cell neighbor : neighbors()) {
                    neighbor.bcount++;
                }
            }
        }

        /*
         * public boolean tryToKillFire() { if(state == CellState.BURNING) {
         * if(random.nextDouble() < pkill) { state = CellState.DESTROYED;
         * for(Cell neighbor : neighbors()) neighbor.bcount--; return true; } }
         * 
         * return false; }
         */
        public Set<Cell> neighbors() {
            
            return neighbors;
        }

        public void setState(CellState state) {
            this.state = state;
            if (i % 2 == 0) {
                fireSpaces.get(i / 2).set(j, k, state);
            }
        }
    }
    /**
     * Enum value indicating the state of the cell and the color to be used to
     * display it.
     */
     public enum CellState {

         /**
          * This is the default initial state of every cell. In this state it 
          * cannot be burned
          */
        EMPTY(new Color(0, 0, 0, 0)),
        /**
         * The state of being burnable but having still not started burning
         */
        UNBURNED(new Color(0, 0, 0, 0)),
        /**
         * The state of burning. In this state there are three colours between 
         * which the cells alternate
         */
        BURNING(Color.red, Color.orange, Color.yellow),
        /**
         * A state in which the cell has been burnt completely to the point of 
         * destruction. Not sure at what stage a cell becomes destroyed
         */
        DESTROYED(new Color(0, 0, 0, 0));
        private ArrayList<Color> possibleColors;

        CellState(Color... colors) {
            this.possibleColors = new ArrayList<Color>();
            this.possibleColors.addAll(Arrays.asList(colors));
        }

        public ArrayList<Color> getColorList() {
            return possibleColors;
        }
    };
}
